// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package vulnerability

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/cenkalti/backoff/v4"
	"github.com/elastic/cloudbeat/resources/providers/awslib/ec2"
	"github.com/elastic/elastic-agent-libs/logp"
	"github.com/reactivex/rxgo/v2"
)

type VulnerabilityVerifier struct {
	log      *logp.Logger
	provider snapshotProvider
	ch       chan ec2.EBSSnapshot
}

type snapshotProvider interface {
	CreateSnapshots(ctx context.Context, ins ec2.Ec2Instance) ([]ec2.EBSSnapshot, error)
	DescribeSnapshots(ctx context.Context, snap ec2.EBSSnapshot) ([]ec2.EBSSnapshot, error)
	DescribeSnapshot(ctx context.Context, snap ec2.EBSSnapshot) (*ec2.EBSSnapshot, error)
}

func NewVulnerabilityVerifier(log *logp.Logger, provider *ec2.Provider) VulnerabilityVerifier {
	log.Debug("VulnerabilityVerifier: New")
	ch := make(chan ec2.EBSSnapshot)
	return VulnerabilityVerifier{
		log:      log,
		ch:       ch,
		provider: provider,
	}
}

// TODO: Maybe verify more than one snapshot
func (f VulnerabilityVerifier) VerifySnapshot(ctx context.Context, snapCh chan ec2.EBSSnapshot) {
	f.log.Info("Starting VulnerabilityVerifier.VerifySnapshot")
	defer close(f.ch)
	for {
		select {
		case <-ctx.Done():
			f.log.Info("VulnerabilityVerifier.VerifySnapshot context canceled")
			return
		case data, ok := <-snapCh:
			if !ok {
				f.log.Info("VulnerabilityVerifier.VerifySnapshot channel is closed")
				return
			}
			f.verify(ctx, data)
		}
	}
}

func (f VulnerabilityVerifier) VerifyRx(ctx context.Context, snap ec2.EBSSnapshot) rxgo.Observable {
	return rxgo.Just(snap)().
		Map(func(ctx context.Context, item interface{}) (interface{}, error) {
			snapshot := item.(ec2.EBSSnapshot)
			snp, err := f.provider.DescribeSnapshot(ctx, snapshot)
			if err != nil {
				return nil, err
			}

			if snp.State != types.SnapshotStateCompleted {
				return nil, fmt.Errorf("Snapshot not completed")
			}

			return *snp, nil
		}).BackOffRetry(
		backoff.WithMaxRetries(
			backoff.NewConstantBackOff(15*time.Second),
			20,
		),
		rxgo.WithContext(ctx),
	)
}

func (f VulnerabilityVerifier) verify(ctx context.Context, snap ec2.EBSSnapshot) {
	f.log.Info("Starting VulnerabilityVerifier.verify")
	// TODO: Change this to variable
	timer := time.After(5 * time.Minute)
	for {
		select {
		case <-timer:
			f.log.Info("VulnerabilityVerifier.verify timed out waiting for snapshot ", snap.SnapshotId)
			return
		case <-ctx.Done():
			f.log.Info("VulnerabilityVerifier.verify context canceled")
			return
		// TODO: Change this to variable
		case <-time.After(15 * time.Second):
			sp, err := f.provider.DescribeSnapshots(ctx, snap)
			if err != nil {
				f.log.Errorf("VulnerabilityVerifier.verify.DescribeSnapshots failed: %v", err)
				continue
			}
			// TOOD: Add a layer of "smart" cache to avoid checking and sending the same snapshot
			// and not to wait on all snapshots to be completed, sending them periodically
			allCompleted := true
			for _, i := range sp {
				if i.State != types.SnapshotStateCompleted {
					f.log.Info("VulnerabilityVerifier.verify.VerifySnapshot snapshot not completed yet - ", snap.SnapshotId, i.SnapshotId)
					allCompleted = false
					break
				}
			}
			if allCompleted {
				for _, i := range sp {
					f.ch <- i
				}
				f.log.Info("VulnerabilityVerifier.verify.VerifySnapshot snapshot completed - ", snap.SnapshotId)
				return
			}
		}
	}
}

func (f VulnerabilityVerifier) GetChan() chan ec2.EBSSnapshot {
	return f.ch
}
